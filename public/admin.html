<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SunoMate - Artist Manager</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        /* COMPACT HEADER */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.3em;
            margin: 0;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.85em;
            margin: 0;
        }

        /* MAIN LAYOUT */
        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* COLLAPSIBLE SIDEBAR - RIGHT SIDE */
        .sidebar {
            width: 0;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow: hidden;
            transition: width 0.3s ease;
            display: flex;
            flex-direction: column;
            order: 2;
        }

        .sidebar.open {
            width: 320px;
        }

        .sidebar-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }

        .sidebar-section {
            margin-bottom: 20px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .sidebar-section h3 {
            font-size: 0.95em;
            margin-bottom: 10px;
            color: #495057;
        }

        .sidebar-section .btn {
            width: 100%;
            margin-bottom: 6px;
            font-size: 13px;
            padding: 8px 12px;
        }

        /* SETTINGS TOGGLE BUTTON - RIGHT SIDE */
        .settings-toggle {
            position: absolute;
            left: 30px;
            top: 80px;
            z-index: 100;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }

        .settings-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* MAIN AREA */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            order: 1;
        }

        /* COMPACT STATS BAR */
        .stats {
            display: flex;
            justify-content: space-around;
            padding: 10px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            flex-shrink: 0;
        }

        .stat-card {
            text-align: center;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .stat-number {
            font-size: 1.4em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.85em;
        }

        /* COMPACT ADD FORM */
        .add-form {
            padding: 12px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            flex-shrink: 0;
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
        }

        .form-row label {
            font-size: 0.85em;
            font-weight: 600;
            color: #495057;
            margin: 0;
        }

        .type-selector {
            display: flex;
            gap: 12px;
        }

        .type-selector label {
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 400;
        }

        .type-selector input[type="radio"] {
            margin-left: 4px;
            width: auto;
        }

        input, textarea, select {
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.3s;
            font-family: inherit;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 50px;
        }

        .name-input-row {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        .name-input-row input {
            flex: 1;
        }

        .style-input {
            width: 100%;
        }

        /* SMALL BUTTONS */
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-ai {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-ai:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(240, 147, 251, 0.4);
        }

        /* SEARCH AND FILTERS */
        .search-section {
            padding: 12px 20px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            flex-shrink: 0;
        }

        .search-bar {
            margin-bottom: 8px;
        }

        .search-bar input {
            width: 100%;
            padding: 8px 12px;
        }

        .filters {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            font-size: 13px;
        }

        .filters select {
            padding: 5px 10px;
            width: auto;
        }

        .display-indicator {
            color: #667eea;
            font-weight: 600;
            white-space: nowrap;
            font-size: 13px;
        }

        .filters .btn {
            font-size: 12px;
            padding: 5px 10px;
        }

        /* ARTISTS LIST - THE STAR */
        .artists-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
            background: white;
        }

        .artist-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 6px 10px;
            margin-bottom: 4px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .artist-card:hover {
            border-color: #667eea;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .artist-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .artist-card.highlighted {
            animation: highlight 2s ease;
        }

        @keyframes highlight {
            0%, 100% { background: white; }
            50% { background: #fff3cd; }
        }

        .artist-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .artist-info {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        .artist-name {
            font-size: 0.95em;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 2px;
        }

        .artist-style {
            color: #718096;
            line-height: 1.3;
            font-size: 0.8em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .artist-details {
            margin-top: 8px;
        }

        .artist-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .artist-actions .btn {
            padding: 4px 8px;
            font-size: 12px;
            min-width: 32px;
        }

        .alert {
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .hidden {
            display: none;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        .form-check {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
        }

        .form-check input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .form-check label {
            margin: 0;
            cursor: pointer;
            font-weight: 400;
            font-size: 0.85em;
        }

        .form-note {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 3px;
        }

        /* MODALS */
        .progress-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .progress-modal.active {
            display: flex;
        }

        .progress-panel {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        /* PROMPT EDITOR MODAL - MUCH LARGER */
        #promptEditorModal .progress-panel,
        #jsonEditorModal .progress-panel {
            max-width: 95% !important;
            width: 95% !important;
            max-height: 90vh !important;
            height: 90vh !important;
        }

        #promptEditorModal .progress-panel textarea,
        #jsonEditorModal .progress-panel textarea {
            flex: 1;
            min-height: 70vh;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            resize: none;
            background: #f8f9fa;
            color: #2d3748;
        }

        #promptEditorModal .progress-header,
        #jsonEditorModal .progress-header {
            flex-shrink: 0;
        }

        #promptEditorModal .progress-footer,
        #jsonEditorModal .progress-footer {
            flex-shrink: 0;
        }

        .progress-header {
            margin-bottom: 20px;
        }

        .progress-header h2 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3em;
        }

        .progress-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .progress-stat {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
        }

        .stat-total { background: #e7f3ff; color: #004085; }
        .stat-new { background: #d4edda; color: #155724; }
        .stat-existing { background: #fff3cd; color: #856404; }
        .stat-skip { background: #f8d7da; color: #721c24; }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85em;
        }

        .progress-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .progress-item {
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.9em;
            border-left: 4px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .progress-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .progress-item-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-item.pending {
            background: #f8f9fa;
            border-left-color: #6c757d;
        }

        .progress-item.processing {
            background: #e7f3ff;
            border-left-color: #667eea;
            animation: pulse 1.5s infinite;
        }

        .progress-item.success {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .progress-item.skipped {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .progress-item.failed {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .progress-item-icon {
            font-size: 1.2em;
            width: 25px;
            text-align: center;
        }

        .progress-item-name {
            flex: 1;
            font-weight: 600;
        }

        .progress-item-status {
            font-size: 0.85em;
            opacity: 0.8;
        }

        .progress-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .progress-footer .btn {
            padding: 8px 16px;
            font-size: 13px;
        }

        /* API Settings in Sidebar */
        .api-settings-sidebar {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px;
        }

        .api-settings-sidebar h3 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .api-indicator {
            font-size: 0.8em;
            color: #856404;
            margin-bottom: 8px;
        }

        .form-group-sidebar {
            margin-bottom: 10px;
        }

        .form-group-sidebar label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #495057;
            font-size: 0.85em;
        }

        .form-group-sidebar select,
        .form-group-sidebar input {
            width: 100%;
            padding: 6px 8px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen" class="container">
        <div class="header">
            <div>
                <h1>ğŸµ Suno Artist Manager</h1>
                <p>Login Required</p>
            </div>
        </div>

        <div style="padding: 30px;">
            <div id="loginAlertContainer"></div>

            <div style="margin-bottom: 20px;">
                <label for="loginPassword" style="display: block; margin-bottom: 8px; font-weight: 600;">Enter Password:</label>
                <input type="password" id="loginPassword" placeholder="Enter password" autofocus style="width: 100%; padding: 12px;">
            </div>

            <div>
                <button class="btn btn-primary" onclick="login()" id="loginBtn" style="padding: 12px 24px; font-size: 16px;">ğŸ”“ Login</button>
            </div>
        </div>
    </div>

    <!-- Main App (hidden by default) -->
    <div id="mainApp" class="container" style="display: none;">
        <!-- Compact Header -->
        <div class="header">
            <div>
                <h1>ğŸµ Suno Artist Manager</h1>
            </div>
            <p>× ×™×”×•×œ ×××’×¨ ××× ×™× ×•×¡×˜×™×™×œ×™× ×œ××•×–×™×§×”</p>
        </div>

        <!-- Settings Toggle Button -->
        <button class="settings-toggle" onclick="toggleSidebar()">
            <span id="settingsToggleText">âš™ï¸ Settings</span>
        </button>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Main Area -->
            <div class="main-area">
                <!-- Compact Stats Bar -->
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="totalArtists">0</div>
                        <div class="stat-label">×¡×”×´×› ××× ×™×</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalSongs">0</div>
                        <div class="stat-label">×¡×”×´×› ×©×™×¨×™×</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="enabledStatus">-</div>
                        <div class="stat-label">×¡×˜×˜×•×¡</div>
                    </div>
                </div>

                <!-- Compact Add Form -->
                <div class="add-form">
                    <div id="alertContainer"></div>

                    <div class="form-row">
                        <label>×¡×•×’:</label>
                        <div class="type-selector">
                            <label>
                                <input type="radio" name="entry-type" value="artist" checked onchange="updateEntryTypeUI()">
                                <span>ğŸ¤ ×××Ÿ</span>
                            </label>
                            <label>
                                <input type="radio" name="entry-type" value="song" onchange="updateEntryTypeUI()">
                                <span>ğŸµ ×©×™×¨</span>
                            </label>
                        </div>
                        <div class="name-input-row">
                            <input type="text" id="artistName" placeholder="×œ×“×•×’××”: Billy Joel">
                            <button class="btn btn-ai" onclick="generateStyle()" id="generateBtn">
                                ğŸ¤– AI Generator
                            </button>
                        </div>
                    </div>

                    <div class="form-row">
                        <label for="artistStyle" id="styleLabel">×ª×™××•×¨ ×”×¡×˜×™×™×œ:</label>
                        <textarea id="artistStyle" class="style-input" placeholder="×œ×“×•×’××”: Pop, Rock, Storytelling, piano-driven, male vocals, upbeat"></textarea>
                    </div>

                    <div class="form-row" style="justify-content: space-between;">
                        <div class="form-check">
                            <input type="checkbox" id="regenerateExisting" checked>
                            <label for="regenerateExisting" id="regenerateLabel">
                                ğŸ”„ Regenerate existing? (×× ×œ× ××¡×•××Ÿ, ×™×“×œ×’ ×¢×œ ×§×™×™××™×)
                            </label>
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <button class="btn btn-primary" onclick="saveEntry()" id="saveBtn">ğŸ’¾ ×©××•×¨/×¢×“×›×Ÿ</button>
                            <button class="btn btn-success" onclick="loadArtists()">ğŸ”„ ×¨×¢× ×Ÿ</button>
                        </div>
                    </div>
                </div>

                <!-- Search and Filters -->
                <div class="search-section">
                    <div class="search-bar">
                        <input type="text" id="searchInput" placeholder="ğŸ” ×—×¤×© ×××Ÿ ××• ×©×™×¨..." onkeyup="filterArtists()">
                    </div>
                    <div class="filters">
                        <button class="btn btn-primary" onclick="sortArtists('name')">ğŸ”¤ Name</button>
                        <button class="btn btn-success" onclick="sortArtists('recent')">ğŸ• Recent</button>
                        <select id="genreFilter" onchange="filterByGenre()">
                            <option value="">All Genres</option>
                        </select>
                        <div class="display-indicator" id="displayIndicator">Showing: 0 | Selected: 0</div>
                        <div style="flex: 1"></div>
                        <button class="btn" onclick="selectAllVisible()" style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); color: white;">â˜‘ï¸ Select All</button>
                        <button class="btn" onclick="deselectAll()" style="background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%); color: white;">â—»ï¸ Deselect All</button>
                        <button class="btn" onclick="regenerateSelected()" id="regenerateSelectedBtn" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;" disabled>
                            ğŸ”„ Regenerate Selected (<span id="selectedCount">0</span>)
                        </button>
                        <button class="btn btn-danger" onclick="regenerateAll()">ğŸ”¥ Regenerate All</button>
                    </div>
                </div>

                <!-- Artists List - THE STAR -->
                <div class="artists-list" id="artistsList">
                    <!-- Artist cards will be added here dynamically -->
                </div>
            </div>

            <!-- Collapsible Sidebar (starts closed) - RIGHT SIDE -->
            <div class="sidebar" id="sidebar">
                <div class="sidebar-content">
                    <!-- System Toggle -->
                    <div class="sidebar-section">
                        <h3>System Control</h3>
                        <div class="toggle-container">
                            <label style="font-weight: 600; font-size: 0.9em;">×”×¤×¢×œ/×›×‘×”:</label>
                            <label class="switch">
                                <input type="checkbox" id="enableToggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>

                    <!-- AI Generator Settings -->
                    <div class="sidebar-section api-settings-sidebar">
                        <h3>ğŸ¤– AI Generator Settings</h3>
                        <div class="api-indicator" id="adminApiIndicator">-</div>

                        <div class="form-group-sidebar">
                            <label for="aiProvider">Provider:</label>
                            <select id="aiProvider" onchange="updateModelDropdown()">
                                <option value="google" selected>ğŸŒ Google (Gemini)</option>
                                <option value="anthropic">ğŸ¤– Anthropic (Claude)</option>
                                <option value="openai">ğŸ’¬ OpenAI (GPT)</option>
                                <option value="xai">âœ–ï¸ X.AI (Grok)</option>
                            </select>
                        </div>

                        <div class="form-group-sidebar">
                            <label for="llmProvider">Model:</label>
                            <select id="llmProvider" onchange="updateAdminApiIndicator()">
                                <!-- Populated dynamically -->
                            </select>
                        </div>

                        <div class="form-group-sidebar">
                            <label for="apiKey">API Key:</label>
                            <input type="password" id="apiKey" placeholder="×”×“×‘×§ ××ª ×”-API key ×©×œ×š ×›××Ÿ" onchange="updateAdminApiIndicator()">
                            <p class="form-note" id="apiKeyNote">×”×–×Ÿ ××ª ×”-API key ×©×œ×š ×œ××•×“×œ ×©×‘×—×¨×ª.</p>
                            <div class="form-check">
                                <input type="checkbox" id="saveApiKey" checked>
                                <label for="saveApiKey">×©××•×¨ API key ×‘×“×¤×“×¤×Ÿ</label>
                            </div>
                        </div>
                    </div>

                    <!-- Prompts Management -->
                    <div class="sidebar-section">
                        <h3>âœ¨ Prompts Management</h3>
                        <button class="btn btn-primary" onclick="openPromptEditor('artist')">
                            ğŸ¤ Edit Artist Prompt
                        </button>
                        <button class="btn" onclick="openPromptEditor('song')" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                            ğŸµ Edit Song Prompt
                        </button>
                    </div>

                    <!-- JSON Management -->
                    <div class="sidebar-section">
                        <h3>ğŸ“ JSON Management</h3>
                        <button class="btn" onclick="downloadJSON()" style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); color: white;">
                            ğŸ“¥ Download
                        </button>
                        <button class="btn btn-primary" onclick="openJsonEditor()">
                            âœï¸ Edit
                        </button>
                        <button class="btn btn-success" onclick="document.getElementById('uploadJsonInput').click()">
                            ğŸ“¤ Upload
                        </button>
                        <button class="btn btn-danger" onclick="clearAllArtists()">
                            ğŸ—‘ï¸ Clear All
                        </button>
                        <input type="file" id="uploadJsonInput" accept=".json" style="display: none;" onchange="handleJsonUpload(event)">
                        <p class="form-note" style="margin-top: 8px;">âš ï¸ ×›×œ ×¤×¢×•×œ×” ×™×•×¦×¨×ª backup ××•×˜×•××˜×™</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Modal -->
    <div id="progressModal" class="progress-modal">
        <div class="progress-panel">
            <div class="progress-header">
                <h2>ğŸ¤– AI Generation Progress</h2>
                <div class="progress-stats">
                    <div class="progress-stat stat-total">
                        Total: <span id="statTotal">0</span>
                    </div>
                    <div class="progress-stat stat-new">
                        New: <span id="statNew">0</span>
                    </div>
                    <div class="progress-stat stat-existing">
                        Existing: <span id="statExisting">0</span>
                    </div>
                    <div class="progress-stat stat-skip">
                        Will Skip: <span id="statSkip">0</span>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
                </div>
            </div>
            <div class="progress-list" id="progressList">
                <!-- Progress items will be added here dynamically -->
            </div>
            <div class="progress-footer">
                <button class="btn btn-primary" id="closeProgressBtn" onclick="closeProgressModal()" style="display: none;">
                    âœ… Close
                </button>
            </div>
        </div>
    </div>

    <!-- JSON Editor Modal -->
    <div id="jsonEditorModal" class="progress-modal">
        <div class="progress-panel">
            <div class="progress-header">
                <h2>âœï¸ Edit JSON Database</h2>
                <p style="color: #6c757d; font-size: 0.9em; margin-top: 8px;">
                    Direct edit of artist_styles.json - Be careful! A backup will be created automatically.
                </p>
            </div>
            <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                <textarea id="jsonEditorTextarea"></textarea>
            </div>
            <div class="progress-footer" style="margin-top: 20px;">
                <button class="btn" onclick="closeJsonEditor()" style="background: #6c757d; color: white;">
                    âœ–ï¸ Cancel
                </button>
                <button class="btn btn-primary" id="saveJsonBtn" onclick="saveEditedJson()">
                    ğŸ’¾ Save JSON
                </button>
            </div>
        </div>
    </div>

    <!-- Prompt Editor Modal - MUCH LARGER -->
    <div id="promptEditorModal" class="progress-modal">
        <div class="progress-panel">
            <div class="progress-header">
                <h2 id="promptEditorTitle">âœï¸ Edit Prompt</h2>
                <p style="color: #6c757d; font-size: 0.9em; margin-top: 8px;" id="promptEditorDesc">
                    Edit the AI prompt template. Use {ARTIST_NAME} or {SONG_NAME} as placeholder.
                </p>
            </div>
            <div style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                <textarea id="promptEditorTextarea"></textarea>
            </div>
            <div class="progress-footer" style="margin-top: 20px;">
                <button class="btn" onclick="closePromptEditor()" style="background: #6c757d; color: white;">
                    âœ–ï¸ Cancel
                </button>
                <button class="btn btn-primary" id="savePromptBtn" onclick="savePrompt()">
                    ğŸ’¾ Save Prompt
                </button>
            </div>
        </div>
    </div>

    <script>
        let artistsData = { enabled: true, artists: {} };
        const API_URL = window.location.origin;
        let serverEnvKeys = {};
        let sessionPassword = ''; // Store password for session
        let selectedArtists = new Set(); // Track selected artists
        let lastClickedIndex = null; // For shift-click selection
        let currentSort = 'name'; // Default sort
        let currentGenreFilter = ''; // Current genre filter
        let currentSearchTerm = ''; // Track current search term

        // Sidebar toggle function
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleText = document.getElementById('settingsToggleText');
            sidebar.classList.toggle('open');
            if (sidebar.classList.contains('open')) {
                toggleText.textContent = 'âœ–ï¸ Close';
            } else {
                toggleText.textContent = 'âš™ï¸ Settings';
            }
        }

        // Login function
        async function login() {
            const loginPassword = document.getElementById('loginPassword').value;
            const loginBtn = document.getElementById('loginBtn');
            const originalText = loginBtn.textContent;

            if (!loginPassword) {
                showLoginAlert('Please enter password', 'error');
                return;
            }

            loginBtn.disabled = true;
            loginBtn.textContent = 'â³ Checking...';

            try {
                // Test password by trying to fetch artists
                const response = await fetch(`${API_URL}/api/artists`);

                if (!response.ok) {
                    throw new Error('Cannot connect to server');
                }

                // Store password in session and localStorage
                sessionPassword = loginPassword;
                localStorage.setItem('adminPassword', loginPassword);

                // Hide login screen
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'flex';

                // Initialize the app
                initializeApp();

                // Load data
                loadArtists();
                initializeApiSettings();

                loginBtn.textContent = 'âœ… Logged in!';

            } catch (error) {
                showLoginAlert('Login failed: ' + error.message, 'error');
                loginBtn.disabled = false;
                loginBtn.textContent = originalText;
            }
        }

        // Check if already logged in
        function checkLogin() {
            const savedPassword = localStorage.getItem('adminPassword');

            if (savedPassword) {
                sessionPassword = savedPassword;
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'flex';
                initializeApp();
                loadArtists();
                initializeApiSettings();
            }
        }

        // Handle Enter key on login
        document.addEventListener('DOMContentLoaded', () => {
            const loginPasswordInput = document.getElementById('loginPassword');
            if (loginPasswordInput) {
                loginPasswordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        login();
                    }
                });
            }
            checkLogin();
        });

        function showLoginAlert(message, type) {
            const alertContainer = document.getElementById('loginAlertContainer');
            const alertClass = type === 'error' ? 'alert-error' : 'alert-success';

            alertContainer.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;

            setTimeout(() => {
                alertContainer.innerHTML = '';
            }, 5000);
        }

        // Helper function to get provider name from model ID
        function getProviderName(modelId) {
            if (!modelId) return 'unknown';
            if (modelId.startsWith('gemini')) { return 'google'; }
            else if (modelId.startsWith('claude')) { return 'anthropic'; }
            else if (modelId.startsWith('gpt') || modelId.startsWith('o')) { return 'openai'; }
            else if (modelId.startsWith('grok')) { return 'xai'; }
            return 'unknown';
        }

        // API Key management (localStorage)
        function saveApiKeyToLocalStorage(provider, apiKey) {
            localStorage.setItem(`apiKey_${provider}`, apiKey);
            console.log(`Saved API key for provider: ${provider}`);
        }

        function loadApiKeyFromLocalStorage(provider) {
            return localStorage.getItem(`apiKey_${provider}`);
        }

        function isApiKeyAvailable(provider) {
            const localKey = loadApiKeyFromLocalStorage(provider);
            return !!localKey;
        }

        // Model options grouped by provider
        const modelsByProvider = {
            google: [
                { value: 'gemini-2.5-flash', label: 'Gemini 2.5 Flash' },
                { value: 'gemini-2.0-flash', label: 'Gemini 2.0 Flash (××•××œ×¥)', selected: true },
                { value: 'gemini-1.5-pro', label: 'Gemini 1.5 Pro' },
                { value: 'gemini-2.5-pro-preview-05-06', label: 'Gemini 2.5 Pro Preview' }
            ],
            anthropic: [
                { value: 'claude-sonnet-4-5-20250929', label: 'Claude 4.5 Sonnet (×”×—×“×© ×‘×™×•×ª×¨)' },
                { value: 'claude-sonnet-4-20250514', label: 'Claude 4 Sonnet' },
                { value: 'claude-3-7-sonnet-20250219', label: 'Claude 3.7 Sonnet' },
                { value: 'claude-3-5-sonnet-latest', label: 'Claude 3.5 Sonnet' },
                { value: 'claude-3-5-haiku-latest', label: 'Claude 3.5 Haiku' },
                { value: 'claude-3-haiku-20240307', label: 'Claude 3 Haiku' }
            ],
            openai: [
                { value: 'gpt-5-chat-latest', label: 'GPT-5 Chat Latest' },
                { value: 'gpt-4.1-2025-04-14', label: 'GPT-4.1' },
                { value: 'gpt-4.1-mini', label: 'GPT-4.1-mini' },
                { value: 'gpt-4o', label: 'GPT-4o' },
                { value: 'o4-mini', label: 'o4-Mini' }
            ],
            xai: [
                { value: 'grok-4-fast-reasoning', label: 'Grok 4 Fast Reasoning' },
                { value: 'grok-4-fast-non-reasoning', label: 'Grok 4 Fast Non-Reasoning' },
                { value: 'grok-4-0709', label: 'Grok 4 (0709)' },
                { value: 'grok-3-mini', label: 'Grok 3 Mini' },
                { value: 'grok-3', label: 'Grok 3' }
            ]
        };

        function updateModelDropdown() {
            const provider = document.getElementById('aiProvider').value;
            const llmProviderSelect = document.getElementById('llmProvider');
            const models = modelsByProvider[provider] || [];

            llmProviderSelect.innerHTML = models.map(model =>
                `<option value="${model.value}" ${model.selected ? 'selected' : ''}>${model.label}</option>`
            ).join('');

            // Update API input state when provider changes
            updateApiInputState(true);
        }

        function updateApiInputState(loadSavedKey = false) {
            const provider = document.getElementById('aiProvider').value;
            const apiKeyInput = document.getElementById('apiKey');
            const apiKeyNote = document.getElementById('apiKeyNote');

            // Update note based on provider
            let noteText = `×”×–×Ÿ API key ×¢×‘×•×¨ ${provider}.`;
            let links = {
                'google': 'https://aistudio.google.com/apikey',
                'anthropic': 'https://console.anthropic.com/',
                'openai': 'https://platform.openai.com/api-keys',
                'xai': 'https://console.x.ai/'
            };

            if (links[provider]) {
                noteText += ` <a href="${links[provider]}" target="_blank" style="color: #667eea;">×§×‘×œ ××¤×ª×— ×›××Ÿ</a>`;
            }

            apiKeyNote.innerHTML = noteText;

            // Only load saved key if explicitly requested (on provider change or page load)
            if (loadSavedKey) {
                const localKey = loadApiKeyFromLocalStorage(provider);
                if (localKey) {
                    apiKeyInput.value = localKey;
                    document.getElementById('saveApiKey').checked = true;
                } else {
                    apiKeyInput.value = '';
                    document.getElementById('saveApiKey').checked = false;
                }
            }
        }

        async function initializeApiSettings() {
            // Load saved provider from localStorage
            const savedProvider = localStorage.getItem('aiProvider') || 'google';
            const savedModel = localStorage.getItem('llmProvider');

            // Set provider
            document.getElementById('aiProvider').value = savedProvider;

            // Populate models for the saved provider
            updateModelDropdown();

            // If there's a saved model for this provider, select it
            if (savedModel && getProviderName(savedModel) === savedProvider) {
                document.getElementById('llmProvider').value = savedModel;
            }

            // Load saved API key
            updateApiInputState(true);

            // Update indicator after models are populated
            updateAdminApiIndicator();
        }

        // Update admin API indicator
        function updateAdminApiIndicator() {
            const provider = document.getElementById('aiProvider').value;
            const savedKey = localStorage.getItem(`apiKey_${provider}`);
            const currentKey = document.getElementById('apiKey').value.trim();
            const hasKey = !!(savedKey || currentKey);

            const llmProviderSelect = document.getElementById('llmProvider');
            const indicator = document.getElementById('adminApiIndicator');

            // Check if options are populated
            if (llmProviderSelect.options.length === 0) {
                indicator.innerHTML = `âš ï¸ Loading...`;
                indicator.style.color = '#6c757d';
                return;
            }

            const modelName = llmProviderSelect.options[llmProviderSelect.selectedIndex].text;

            if (hasKey) {
                indicator.innerHTML = `âœ… ${modelName}`;
                indicator.style.color = '#28a745';
            } else {
                indicator.innerHTML = `âš ï¸ No API key`;
                indicator.style.color = '#dc3545';
            }
        }

        // Initialize app after login
        function initializeApp() {
            // Setup toggle listener
            setupToggleListener();
        }

        function setupToggleListener() {
            const toggle = document.getElementById('enableToggle');
            toggle.addEventListener('change', async function() {
                const enabled = this.checked;

                try {
                    const response = await fetch(`${API_URL}/api/enabled`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            enabled,
                            password: sessionPassword
                        })
                    });

                    const result = await response.json();

                    if (response.ok) {
                        showAlert(`×”××¢×¨×›×ª ${enabled ? '×”×•×¤×¢×œ×”' : '×›×•×‘×ª×”'} ×‘×”×¦×œ×—×”!`, 'success');
                        updateStats();
                    } else {
                        throw new Error(result.error || 'Failed to update');
                    }
                } catch (error) {
                    showAlert('×©×’×™××”: ' + error.message, 'error');
                    this.checked = !enabled; // Revert on error
                }
            });
        }

        function updateToggle() {
            document.getElementById('enableToggle').checked = artistsData.enabled;
        }

        async function loadArtists() {
            try {
                const response = await fetch(`${API_URL}/api/artists`);
                const data = await response.json();

                artistsData = data;

                displayArtists();
                updateStats();

            } catch (error) {
                showAlert('×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™×: ' + error.message, 'error');
            }
        }

        function displayArtists(highlightArtist = null) {
            const artistsList = document.getElementById('artistsList');

            // Get both artists and songs
            let artists = Object.entries(artistsData.artists || {}).map(([name, style]) => ({name, style, type: 'artist'}));
            let songs = Object.entries(artistsData.songs || {}).map(([name, style]) => ({name, style, type: 'song'}));
            let allEntries = [...artists, ...songs];

            if (allEntries.length === 0) {
                artistsList.innerHTML = '<p style="text-align: center; color: #6c757d; padding: 40px;">××™×Ÿ ××× ×™× ××• ×©×™×¨×™× ×‘×××’×¨</p>';
                return;
            }

            // Add timestamps from metadata
            const entriesWithMeta = allEntries.map(entry => {
                const timestamp = entry.type === 'artist'
                    ? artistsData.metadata?.[entry.name]?.timestamp || 0
                    : artistsData.metadata?.songs?.[entry.name]?.timestamp || 0;
                return {...entry, timestamp};
            });

            // Filter
            let filteredEntries = entriesWithMeta.filter(entry => {
                const matchesSearch = !currentSearchTerm ||
                    entry.name.toLowerCase().includes(currentSearchTerm) ||
                    entry.style.toLowerCase().includes(currentSearchTerm);
                const genre = getGenreFromStyle(entry.style);
                const matchesGenre = !currentGenreFilter || genre === currentGenreFilter;
                return matchesSearch && matchesGenre;
            });

            // Sort based on current sort mode
            if (currentSort === 'name') {
                filteredEntries.sort((a, b) => a.name.localeCompare(b.name));
            } else if (currentSort === 'recent') {
                filteredEntries.sort((a, b) => b.timestamp - a.timestamp);
            }

            // Populate genre filter
            populateGenreFilter();

            artistsList.innerHTML = filteredEntries.map((entry, index) => {
                const {name, style, type, timestamp} = entry;
                const isSelected = selectedArtists.has(name);
                const isHighlighted = highlightArtist === name;
                const icon = type === 'song' ? 'ğŸµ' : 'ğŸ¤';
                const genre = getGenreFromStyle(style);

                return `
                    <div class="artist-card ${isSelected ? 'selected' : ''} ${isHighlighted ? 'highlighted' : ''}" data-name="${name}" data-index="${index}" data-genre="${genre}" data-type="${type}">
                        <input type="checkbox" class="artist-checkbox"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleArtistSelection('${escapeHtml(name)}', event)"
                               onclick="handleCheckboxClick(event, ${index})">
                        <div class="artist-info" onclick="toggleArtistDetails('${escapeHtml(name)}')">
                            <div class="artist-name">${icon} ${name}</div>
                            <div class="artist-style" title="${escapeHtml(style)}">${style}</div>
                            <div class="artist-details" id="details-${escapeHtml(name)}" style="display: none;">
                                <textarea class="edit-textarea" id="edit-${escapeHtml(name)}" data-type="${type}" style="width: 100%; margin-top: 10px; padding: 8px; border-radius: 4px; border: 1px solid #dee2e6; font-size: 0.9em;">${escapeHtml(style)}</textarea>
                                <button class="btn btn-primary" onclick="saveInlineEdit('${escapeHtml(name)}', '${type}'); event.stopPropagation();" style="margin-top: 8px; padding: 4px 12px; font-size: 0.85em;">ğŸ’¾ ×©××•×¨</button>
                            </div>
                        </div>
                        <div class="artist-actions">
                            <button class="btn btn-primary" onclick="editEntry('${escapeHtml(name)}', '${escapeHtml(style)}', '${type}'); event.stopPropagation();" title="×¢×¨×•×š">âœï¸</button>
                            <button class="btn btn-success" onclick="regenerateEntry('${escapeHtml(name)}', '${type}'); event.stopPropagation();" title="×¦×•×¨ ××—×“×©">ğŸ”„</button>
                            <button class="btn btn-danger" onclick="deleteEntry('${escapeHtml(name)}', '${type}'); event.stopPropagation();" title="××—×§">ğŸ—‘ï¸</button>
                        </div>
                    </div>
                `;
            }).join('');

            // Scroll to highlighted artist
            if (highlightArtist) {
                setTimeout(() => {
                    const card = document.querySelector(`.artist-card[data-name="${highlightArtist}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }

            updateDisplayIndicator();
        }

        function getGenreFromStyle(style) {
            if (!style) return 'Unknown';

            // Common main genres to detect (case-insensitive)
            const mainGenres = [
                'Pop', 'Rock', 'Hip-Hop', 'Rap', 'Jazz', 'Blues', 'Country', 'Electronic',
                'Dance', 'Classical', 'R&B', 'RnB', 'Soul', 'Funk', 'Reggae', 'Metal',
                'Punk', 'Folk', 'Indie', 'Alternative', 'Gospel', 'Latin', 'Ska',
                'Disco', 'House', 'Techno', 'Trance', 'Dubstep', 'Reggaeton',
                'Psytrance', 'Qawwali', 'Rockabilly', 'Roll', 'Salsa', 'Score',
                'Senegalese', 'Shoegaze', 'Son', 'Revival'
            ];

            // Convert to lowercase for comparison
            const styleLower = style.toLowerCase();

            // Check each main genre
            for (const genre of mainGenres) {
                const genreLower = genre.toLowerCase();

                // Check if style contains this genre (as whole word or part of compound)
                // Match patterns like: "pop", "synth-pop", "dark pop", "pop rock"
                const regex = new RegExp(`(^|[\\s,-]|dark |synth-|indie-|alt-|electro-|dream-|art-|power-)${genreLower}([\\s,.-]|$)`, 'i');

                if (regex.test(styleLower)) {
                    return genre; // Return with proper capitalization
                }
            }

            // If no main genre found, get first word from style
            const firstPart = style.split(',')[0].trim();
            const words = firstPart.split(/[\s-]/); // Split by space or hyphen

            // Capitalize first letter
            const fallback = words[words.length - 1];
            return fallback.charAt(0).toUpperCase() + fallback.slice(1).toLowerCase();
        }

        function populateGenreFilter() {
            const genres = new Set();

            // Get genres from artists
            Object.values(artistsData.artists || {}).forEach(style => {
                const genre = getGenreFromStyle(style);
                genres.add(genre);
            });

            // Get genres from songs
            Object.values(artistsData.songs || {}).forEach(style => {
                const genre = getGenreFromStyle(style);
                genres.add(genre);
            });

            const genreFilter = document.getElementById('genreFilter');
            const currentValue = genreFilter.value;

            genreFilter.innerHTML = '<option value="">All Genres</option>' +
                Array.from(genres).sort().map(genre =>
                    `<option value="${genre}">${genre}</option>`
                ).join('');

            if (currentValue) genreFilter.value = currentValue;
        }

        function updateGenreFilter(artistsWithMeta) {
            const genreFilter = document.getElementById('genreFilter');
            const genres = new Set();

            artistsWithMeta.forEach(([name, style]) => {
                const genre = getGenreFromStyle(style);
                genres.add(genre);
            });

            const sortedGenres = Array.from(genres).sort();
            const currentValue = genreFilter.value;

            genreFilter.innerHTML = '<option value="">All Genres</option>' +
                sortedGenres.map(genre => `<option value="${genre}">${genre}</option>`).join('');

            genreFilter.value = currentValue;
        }

        function filterByGenre() {
            const genreFilter = document.getElementById('genreFilter');
            currentGenreFilter = genreFilter.value;
            displayArtists();
        }

        function toggleArtistSelection(name, event) {
            if (event.target.checked) {
                selectedArtists.add(name);
            } else {
                selectedArtists.delete(name);
            }

            const card = document.querySelector(`.artist-card[data-name="${name}"]`);
            if (card) {
                card.classList.toggle('selected', event.target.checked);
            }

            updateSelectedCount();
        }

        function handleCheckboxClick(event, index) {
            if (event.shiftKey && lastClickedIndex !== null) {
                // Shift-click: select range
                const start = Math.min(lastClickedIndex, index);
                const end = Math.max(lastClickedIndex, index);
                const cards = document.querySelectorAll('.artist-card');

                for (let i = start; i <= end; i++) {
                    const card = cards[i];
                    if (card) {
                        const name = card.dataset.name;
                        const checkbox = card.querySelector('.artist-checkbox');
                        checkbox.checked = true;
                        selectedArtists.add(name);
                        card.classList.add('selected');
                    }
                }

                updateSelectedCount();
                event.preventDefault();
            }

            lastClickedIndex = index;
        }

        function updateSelectedCount() {
            document.getElementById('selectedCount').textContent = selectedArtists.size;
            document.getElementById('regenerateSelectedBtn').disabled = selectedArtists.size === 0;
            updateDisplayIndicator();
        }

        function updateDisplayIndicator() {
            const allCards = document.querySelectorAll('.artist-card');
            let visibleCount = 0;

            allCards.forEach(card => {
                if (card.style.display !== 'none') {
                    visibleCount++;
                }
            });

            const indicator = document.getElementById('displayIndicator');
            indicator.textContent = `Showing: ${visibleCount} | Selected: ${selectedArtists.size}`;
        }

        function selectAllVisible() {
            const allCards = document.querySelectorAll('.artist-card');

            allCards.forEach(card => {
                if (card.style.display !== 'none') {
                    const name = card.dataset.name;
                    const checkbox = card.querySelector('.artist-checkbox');

                    selectedArtists.add(name);
                    checkbox.checked = true;
                    card.classList.add('selected');
                }
            });

            updateSelectedCount();
            showAlert(`×‘×—×¨×ª ${selectedArtists.size} ××× ×™×`, 'success');
        }

        function deselectAll() {
            const allCards = document.querySelectorAll('.artist-card');

            allCards.forEach(card => {
                const checkbox = card.querySelector('.artist-checkbox');
                checkbox.checked = false;
                card.classList.remove('selected');
            });

            selectedArtists.clear();
            lastClickedIndex = null;
            updateSelectedCount();
            showAlert('×”×‘×—×™×¨×” ×‘×•×˜×œ×”', 'success');
        }

        function sortArtists(type) {
            currentSort = type;
            displayArtists();
        }

        function filterArtists() {
            currentSearchTerm = document.getElementById('searchInput').value.toLowerCase();
            displayArtists();
        }

        function applySearchFilter() {
            const cards = document.querySelectorAll('.artist-card');

            cards.forEach(card => {
                const name = card.dataset.name.toLowerCase();
                if (name.includes(currentSearchTerm)) {
                    card.style.display = 'flex';
                } else {
                    card.style.display = 'none';
                }
            });

            updateDisplayIndicator();
        }

        function toggleArtistDetails(name) {
            const detailsDiv = document.getElementById(`details-${name}`);
            if (detailsDiv) {
                const isVisible = detailsDiv.style.display !== 'none';
                detailsDiv.style.display = isVisible ? 'none' : 'block';
            }
        }

        function updateStats() {
            const totalArtists = Object.keys(artistsData.artists || {}).length;
            const totalSongs = Object.keys(artistsData.songs || {}).length;
            const enabled = artistsData.enabled;

            document.getElementById('totalArtists').textContent = totalArtists;
            document.getElementById('totalSongs').textContent = totalSongs;
            document.getElementById('enabledStatus').textContent = enabled ? 'âœ…' : 'âŒ';
            document.getElementById('enableToggle').checked = enabled;
        }

        function updateEntryTypeUI() {
            const type = document.querySelector('input[name="entry-type"]:checked').value;
            const nameLabel = document.getElementById('artistName');
            const saveBtn = document.getElementById('saveBtn');
            const regenerateLabel = document.getElementById('regenerateLabel');

            if (type === 'song') {
                nameLabel.placeholder = '×œ×“×•×’××”: Bohemian Rhapsody';
                saveBtn.textContent = 'ğŸ’¾ ×©××•×¨/×¢×“×›×Ÿ ×©×™×¨';
                regenerateLabel.textContent = 'ğŸ”„ Regenerate existing songs? (×× ×œ× ××¡×•××Ÿ, ×™×“×œ×’ ×¢×œ ×©×™×¨×™× ×§×™×™××™×)';
            } else {
                nameLabel.placeholder = '×œ×“×•×’××”: Billy Joel';
                saveBtn.textContent = 'ğŸ’¾ ×©××•×¨/×¢×“×›×Ÿ ×××Ÿ';
                regenerateLabel.textContent = 'ğŸ”„ Regenerate existing artists? (×× ×œ× ××¡×•××Ÿ, ×™×“×œ×’ ×¢×œ ××× ×™× ×§×™×™××™×)';
            }
        }

        async function saveEntry() {
            const name = document.getElementById('artistName').value.trim();
            const style = document.getElementById('artistStyle').value.trim();
            const type = document.querySelector('input[name="entry-type"]:checked').value;

            if (!name || !style) {
                showAlert('× × ×œ××œ× ××ª ×›×œ ×”×©×“×•×ª!', 'error');
                return;
            }

            const isArtist = type === 'artist';
            const endpoint = isArtist ? '/api/artists' : '/api/songs';

            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.textContent;
            saveBtn.disabled = true;
            saveBtn.textContent = 'â³ ×©×•××¨...';

            try {
                const response = await fetch(`${API_URL}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        style,
                        password: sessionPassword
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert(`âœ… ${name} × ×©××¨ ×‘×”×¦×œ×—×”!`, 'success');
                    document.getElementById('artistName').value = '';
                    document.getElementById('artistStyle').value = '';
                    loadArtists();
                } else {
                    throw new Error(result.error || 'Failed to save');
                }
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            } finally {
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }

        async function saveInlineEdit(name, type) {
            const textarea = document.getElementById(`edit-${name}`);
            const newStyle = textarea.value.trim();

            if (!newStyle) {
                showAlert('×”×¡×˜×™×™×œ ×œ× ×™×›×•×œ ×œ×”×™×•×ª ×¨×™×§', 'error');
                return;
            }

            const isArtist = type === 'artist';
            const endpoint = isArtist ? '/api/artists' : '/api/songs';

            try {
                const response = await fetch(`${API_URL}${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, style: newStyle, password: sessionPassword })
                });

                const data = await response.json();

                if (response.ok) {
                    showAlert(`×”${type === 'artist' ? '×××Ÿ' : '×©×™×¨'} ×¢×•×“×›×Ÿ ×‘×”×¦×œ×—×”!`, 'success');

                    // Reload and keep the entry in view with search filter
                    await loadArtists();

                    // Keep search focused on this entry
                    document.getElementById('searchInput').value = name;
                    currentSearchTerm = name.toLowerCase();

                    displayArtists(name);
                } else {
                    showAlert(data.error || '×©×’×™××” ×‘×©××™×¨×”', 'error');
                }
            } catch (error) {
                showAlert('×©×’×™××ª ×¨×©×ª', 'error');
            }
        }

        async function deleteEntry(name, type) {
            const typeLabel = type === 'artist' ? '×××Ÿ' : '×©×™×¨';

            if (!confirm(`×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×”${typeLabel} ${name}?`)) {
                return;
            }

            const isArtist = type === 'artist';
            const endpoint = isArtist ? '/api/artists' : '/api/songs';

            try {
                const response = await fetch(`${API_URL}${endpoint}/${encodeURIComponent(name)}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: sessionPassword })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert(`×”${typeLabel} × ××—×§ ×‘×”×¦×œ×—×”`, 'success');
                    selectedArtists.delete(name);
                    loadArtists();
                } else {
                    showAlert(result.error || '×©×’×™××” ×‘××—×™×§×”', 'error');
                }
            } catch (error) {
                showAlert('×©×’×™××ª ×¨×©×ª', 'error');
            }
        }

        function editEntry(name, style, type) {
            document.getElementById('artistName').value = name;
            document.getElementById('artistStyle').value = style;

            // Set the correct radio button
            const radioButton = document.querySelector(`input[name="entry-type"][value="${type}"]`);
            if (radioButton) {
                radioButton.checked = true;
                updateEntryTypeUI();
            }

            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        async function regenerateEntry(name, type) {
            // Get API settings
            const provider = document.getElementById('aiProvider').value;
            const model = document.getElementById('llmProvider').value;
            const apiKeyInput = document.getElementById('apiKey').value.trim();

            // Get API key
            let apiKey = apiKeyInput || loadApiKeyFromLocalStorage(provider);

            if (!apiKey) {
                showAlert('API Key ×—×¡×¨! ×”×–×Ÿ API key ×‘×”×’×“×¨×•×ª.', 'error');
                return;
            }

            // Find the artist card to show loading state
            const cards = document.querySelectorAll('.artist-card');
            let targetCard = null;
            for (const card of cards) {
                if (card.dataset.name === name) {
                    targetCard = card;
                    break;
                }
            }

            if (targetCard) {
                const styleDiv = targetCard.querySelector('.artist-style');
                const originalStyle = styleDiv.textContent;
                styleDiv.innerHTML = '<span style="color: #667eea;">â³ Generating...</span>';
            }

            try {
                const response = await fetch(`${API_URL}/api/generate-style`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        artistName: name,
                        password: sessionPassword,
                        llmProvider: model,
                        apiKey: apiKey,
                        type: type
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    const newStyle = result.generatedStyle;

                    // Auto-save the new style
                    const isArtist = type === 'artist';
                    const endpoint = isArtist ? '/api/artists' : '/api/songs';
                    const saveResponse = await fetch(`${API_URL}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name,
                            style: newStyle,
                            password: sessionPassword
                        })
                    });

                    if (saveResponse.ok) {
                        showAlert(`âœ¨ "${name}" regenerated and saved!`, 'success');
                        loadArtists(); // Reload the list
                    } else {
                        throw new Error('Failed to save regenerated style');
                    }
                } else {
                    throw new Error(result.error || 'Failed to generate');
                }
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
                if (targetCard) {
                    loadArtists(); // Reload to restore original
                }
            }
        }

        async function generateStyle() {
            const artistNameInput = document.getElementById('artistName').value.trim();
            const llmProvider = document.getElementById('llmProvider').value;
            const apiKey = document.getElementById('apiKey').value.trim();
            const generateBtn = document.getElementById('generateBtn');
            const originalText = generateBtn.innerHTML;
            const entryType = document.querySelector('input[name="entry-type"]:checked').value;
            const isArtist = entryType === 'artist';

            if (!artistNameInput) {
                showAlert(`× × ×œ×”×–×™×Ÿ ×©× ${isArtist ? '×××Ÿ' : '×©×™×¨'} ×ª×—×™×œ×”`, 'error');
                return;
            }

            // Check if API key is available
            if (!apiKey) {
                showAlert(`×“×¨×•×© API key. ×”×–×Ÿ ×‘××§×˜×¢ "×”×’×“×¨×•×ª AI Generator".`, 'error');
                return;
            }

            // Auto-save API key if checkbox is checked
            const saveApiKeyCheckbox = document.getElementById('saveApiKey');
            if (saveApiKeyCheckbox.checked && apiKey) {
                const provider = document.getElementById('aiProvider').value;
                saveApiKeyToLocalStorage(provider, apiKey);
                localStorage.setItem('aiProvider', provider);
                localStorage.setItem('llmProvider', llmProvider);
            }

            // Check if multiple entries (separated by commas)
            const artistNames = artistNameInput.split(',').map(name => name.trim()).filter(name => name.length > 0);

            if (artistNames.length === 0) {
                showAlert(`× × ×œ×”×–×™×Ÿ ×©× ${isArtist ? '×××Ÿ' : '×©×™×¨'} ×ª×§×™×Ÿ`, 'error');
                return;
            }

            // Check regenerate existing checkbox
            const regenerateExisting = document.getElementById('regenerateExisting').checked;

            // Show loading state
            generateBtn.disabled = true;
            generateBtn.innerHTML = `â³ ×× ×ª×— × ×ª×•× ×™×...`;

            let successCount = 0;
            let failCount = 0;
            let skippedCount = 0;
            let regeneratedCount = 0;
            let newCount = 0;

            try {
                // PHASE 1: Load fresh data and analyze
                console.log('ğŸ”„ Loading fresh data from server...');
                const artistsResponse = await fetch(`${API_URL}/api/artists`);
                const currentArtistsData = await artistsResponse.json();
                console.log(`ğŸ“Š Loaded ${Object.keys(currentArtistsData.artists || {}).length} artists, ${Object.keys(currentArtistsData.songs || {}).length} songs`);
                console.log(`âš™ï¸ Regenerate existing: ${regenerateExisting ? 'YES' : 'NO'}`);

                // PHASE 2: Pre-check all entries and categorize
                const collection = isArtist ? (currentArtistsData.artists || {}) : (currentArtistsData.songs || {});

                let existingArtists = [];
                let newArtists = [];
                let willSkip = 0;

                for (const artistName of artistNames) {
                    // Case-insensitive + diacritic-insensitive check
                    const nameNormalized = normalizeArtistName(artistName);
                    const artistExists = Object.keys(collection).find(
                        key => normalizeArtistName(key) === nameNormalized
                    );

                    if (artistExists) {
                        existingArtists.push(artistName);
                        if (!regenerateExisting) {
                            willSkip++;
                        }
                    } else {
                        newArtists.push(artistName);
                    }
                }

                console.log(`ğŸ“‹ Analysis: ${newArtists.length} new, ${existingArtists.length} existing, ${willSkip} will skip`);

                // PHASE 3: Open progress modal and show stats
                document.getElementById('progressList').innerHTML = ''; // Clear previous items
                openProgressModal();
                updateProgressStats(artistNames.length, newArtists.length, existingArtists.length, willSkip);

                // PHASE 4: Add all entries to progress list as pending
                for (const artistName of artistNames) {
                    addProgressItem(artistName, 'pending');
                }

                // PHASE 5: Process each entry
                generateBtn.innerHTML = `â³ ××¢×‘×“ ${artistNames.length} ${isArtist ? '××× ×™×' : '×©×™×¨×™×'}...`;
                let processedCount = 0;

                for (const artistName of artistNames) {
                    try {
                        // Check if entry already exists (case-insensitive + diacritic-insensitive)
                        const nameNormalized = normalizeArtistName(artistName);
                        const artistExists = Object.keys(collection).find(
                            key => normalizeArtistName(key) === nameNormalized
                        );

                        // Skip if exists and regenerateExisting is not checked
                        if (artistExists && !regenerateExisting) {
                            skippedCount++;
                            processedCount++;
                            const existingStyle = collection[artistExists];
                            updateProgressItem(artistName, 'skipped', 'Already exists', existingStyle);
                            updateProgressBar(processedCount, artistNames.length);
                            console.log(`â­ï¸ "${artistName}": SKIPPED`);
                            continue;
                        }

                        // Update status to processing
                        updateProgressItem(artistName, 'processing');

                        // Generate style for this entry
                        const response = await fetch(`${API_URL}/api/generate-style`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                artistName,
                                password: sessionPassword,
                                llmProvider,
                                apiKey: apiKey,
                                type: entryType
                            })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            const generatedStyle = data.generatedStyle;

                            // Auto-save this entry
                            const saveEndpoint = isArtist ? '/api/artists' : '/api/songs';
                            const saveResponse = await fetch(`${API_URL}${saveEndpoint}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    name: artistName,
                                    style: generatedStyle,
                                    password: sessionPassword
                                })
                            });

                            if (saveResponse.ok) {
                                successCount++;
                                processedCount++;
                                if (artistExists) {
                                    regeneratedCount++;
                                    updateProgressItem(artistName, 'success', 'Regenerated', generatedStyle);
                                    console.log(`ğŸ”„ ${artistName}: regenerated`);
                                } else {
                                    newCount++;
                                    updateProgressItem(artistName, 'success', 'Created new', generatedStyle);
                                    console.log(`âœ“ ${artistName}: created new`);
                                }
                                updateProgressBar(processedCount, artistNames.length);
                            } else {
                                failCount++;
                                processedCount++;
                                updateProgressItem(artistName, 'failed', 'Save failed', generatedStyle);
                                updateProgressBar(processedCount, artistNames.length);
                                console.error(`âœ— ${artistName}: save failed`);
                            }
                        } else {
                            failCount++;
                            processedCount++;
                            updateProgressItem(artistName, 'failed', data.error || 'Generation failed', null);
                            updateProgressBar(processedCount, artistNames.length);
                            console.error(`âœ— ${artistName}: ${data.error}`);
                        }
                    } catch (error) {
                        failCount++;
                        processedCount++;
                        updateProgressItem(artistName, 'failed', error.message, null);
                        updateProgressBar(processedCount, artistNames.length);
                        console.error(`âœ— ${artistName}: ${error.message}`);
                    }
                }

                // PHASE 6: Complete - show close button
                document.getElementById('closeProgressBtn').style.display = 'block';

                // Clear the input fields
                document.getElementById('artistName').value = '';
                document.getElementById('artistStyle').value = '';

                // Reload artists list
                loadArtists();

                // Build detailed result message
                let resultParts = [];
                if (newCount > 0) resultParts.push(`âœ¨ ${newCount} ×—×“×©×™×`);
                if (regeneratedCount > 0) resultParts.push(`ğŸ”„ ${regeneratedCount} regenerated`);
                if (skippedCount > 0) resultParts.push(`â­ï¸ ${skippedCount} × ×“×œ×’×•`);
                if (failCount > 0) resultParts.push(`âŒ ${failCount} × ×›×©×œ×•`);

                const resultMessage = resultParts.join(' | ');

                console.log(`âœ… COMPLETE! ${resultMessage}`);

                // Success animation on button
                if (successCount > 0) {
                    generateBtn.innerHTML = `âœ… ×”×•×©×œ×: ${successCount} success`;
                    generateBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                } else if (skippedCount > 0) {
                    generateBtn.innerHTML = `â­ï¸ ${skippedCount} × ×“×œ×’×•`;
                    generateBtn.style.background = 'linear-gradient(135deg, #6c757d 0%, #5a6268 100%)';
                } else {
                    generateBtn.innerHTML = `âŒ ${failCount} × ×›×©×œ×•`;
                    generateBtn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                }

                setTimeout(() => {
                    generateBtn.innerHTML = originalText;
                    generateBtn.style.background = '';
                    generateBtn.disabled = false;
                }, 3000);

            } catch (error) {
                console.error('âŒ Critical error:', error);
                showAlert('×©×’×™××” ×›×œ×œ×™×ª: ' + error.message, 'error');
                closeProgressModal();
                generateBtn.innerHTML = originalText;
                generateBtn.disabled = false;
            }
        }

        async function regenerateSelected() {
            if (selectedArtists.size === 0) {
                showAlert('×œ× × ×‘×—×¨×• ××× ×™×', 'error');
                return;
            }

            const llmProvider = document.getElementById('llmProvider').value;
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                showAlert('×“×¨×•×© API key. ×”×–×Ÿ ×‘××§×˜×¢ "×”×’×“×¨×•×ª AI Generator".', 'error');
                return;
            }

            const regenerateBtn = document.getElementById('regenerateSelectedBtn');
            const originalText = regenerateBtn.innerHTML;
            regenerateBtn.disabled = true;
            regenerateBtn.innerHTML = `â³ ××¢×‘×“ ${selectedArtists.size} ××× ×™×...`;

            let successCount = 0;
            let failCount = 0;

            try {
                const selectedNames = Array.from(selectedArtists);

                for (const artistName of selectedNames) {
                    try {
                        // Find the card and show loading
                        const card = document.querySelector(`.artist-card[data-name="${artistName}"]`);
                        const entryType = card ? card.dataset.type : 'artist';
                        const isArtist = entryType === 'artist';

                        if (card) {
                            const styleDiv = card.querySelector('.artist-style');
                            styleDiv.innerHTML = '<span style="color: #667eea;">â³ Generating...</span>';
                        }

                        // Generate new style
                        const response = await fetch(`${API_URL}/api/generate-style`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                artistName,
                                password: sessionPassword,
                                llmProvider,
                                apiKey: apiKey,
                                type: entryType
                            })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            const newStyle = data.generatedStyle;

                            // Auto-save
                            const saveEndpoint = isArtist ? '/api/artists' : '/api/songs';
                            const saveResponse = await fetch(`${API_URL}${saveEndpoint}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    name: artistName,
                                    style: newStyle,
                                    password: sessionPassword
                                })
                            });

                            if (saveResponse.ok) {
                                successCount++;
                                console.log(`âœ“ ${artistName}: regenerated`);
                            } else {
                                failCount++;
                            }
                        } else {
                            failCount++;
                        }
                    } catch (error) {
                        failCount++;
                        console.error(`âœ— ${artistName}: ${error.message}`);
                    }
                }

                // Clear selection
                selectedArtists.clear();

                // Reload
                await loadArtists();
                displayArtists();

                if (successCount > 0) {
                    showAlert(`âœ¨ ${successCount} ××× ×™× regenerated!${failCount > 0 ? ` (${failCount} × ×›×©×œ×•)` : ''}`, 'success');
                } else {
                    showAlert(`âŒ ×›×œ ${failCount} ×”××× ×™× × ×›×©×œ×•`, 'error');
                }

            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            } finally {
                regenerateBtn.innerHTML = originalText;
                regenerateBtn.disabled = selectedArtists.size === 0;
            }
        }

        async function regenerateAll() {
            const llmProvider = document.getElementById('llmProvider').value;
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                showAlert('×“×¨×•×© API key. ×”×–×Ÿ ×‘××§×˜×¢ "×”×’×“×¨×•×ª AI Generator".', 'error');
                return;
            }

            const totalArtists = Object.keys(artistsData.artists || {}).length;
            const totalSongs = Object.keys(artistsData.songs || {}).length;
            const total = totalArtists + totalSongs;

            if (!confirm(`âš ï¸ WARNING: This will regenerate ALL ${total} entries (${totalArtists} artists, ${totalSongs} songs) using AI. This may take a while and cost API credits. Continue?`)) {
                return;
            }

            showAlert(`ğŸ”¥ Starting regeneration of ${total} entries...`, 'success');

            let successCount = 0;
            let failCount = 0;

            try {
                // Get all artists and songs
                const allArtists = Object.keys(artistsData.artists || {}).map(name => ({name, type: 'artist'}));
                const allSongs = Object.keys(artistsData.songs || {}).map(name => ({name, type: 'song'}));
                const allEntries = [...allArtists, ...allSongs];

                for (let i = 0; i < allEntries.length; i++) {
                    const {name: artistName, type: entryType} = allEntries[i];
                    const isArtist = entryType === 'artist';

                    try {
                        console.log(`[${i + 1}/${allEntries.length}] Regenerating: ${artistName}`);

                        // Generate new style
                        const response = await fetch(`${API_URL}/api/generate-style`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                artistName,
                                password: sessionPassword,
                                llmProvider,
                                apiKey: apiKey,
                                type: entryType
                            })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            const newStyle = data.generatedStyle;

                            // Auto-save
                            const saveEndpoint = isArtist ? '/api/artists' : '/api/songs';
                            const saveResponse = await fetch(`${API_URL}${saveEndpoint}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    name: artistName,
                                    style: newStyle,
                                    password: sessionPassword
                                })
                            });

                            if (saveResponse.ok) {
                                successCount++;
                            } else {
                                failCount++;
                            }
                        } else {
                            failCount++;
                        }

                        // Update progress every 10 entries
                        if ((i + 1) % 10 === 0) {
                            showAlert(`Progress: ${i + 1}/${allEntries.length} (âœ“ ${successCount} | âœ— ${failCount})`, 'success');
                        }

                    } catch (error) {
                        failCount++;
                        console.error(`âœ— ${artistName}: ${error.message}`);
                    }
                }

                // Reload
                await loadArtists();
                displayArtists();

                showAlert(`âœ… Regeneration complete! âœ“ ${successCount} | âœ— ${failCount}`, 'success');

            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            }
        }

        function openProgressModal() {
            document.getElementById('progressModal').classList.add('active');
        }

        function closeProgressModal() {
            document.getElementById('progressModal').classList.remove('active');
        }

        function updateProgressStats(total, newCount, existingCount, skipCount) {
            document.getElementById('statTotal').textContent = total;
            document.getElementById('statNew').textContent = newCount;
            document.getElementById('statExisting').textContent = existingCount;
            document.getElementById('statSkip').textContent = skipCount;
        }

        function updateProgressBar(current, total) {
            const percentage = Math.round((current / total) * 100);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
        }

        function addProgressItem(artistName, status = 'pending') {
            const progressList = document.getElementById('progressList');
            const item = document.createElement('div');
            item.className = `progress-item ${status}`;
            item.id = `progress-${artistName.replace(/\s+/g, '-')}`;
            item.style.cursor = 'pointer';

            const icons = {
                pending: 'â¸ï¸',
                processing: 'â³',
                success: 'âœ…',
                skipped: 'â­ï¸',
                failed: 'âŒ'
            };

            const statusText = {
                pending: 'Waiting...',
                processing: 'Generating...',
                success: 'Success',
                skipped: 'Skipped',
                failed: 'Failed'
            };

            item.innerHTML = `
                <div class="progress-item-row">
                    <div class="progress-item-icon">${icons[status]}</div>
                    <div class="progress-item-name">${artistName}</div>
                    <div class="progress-item-status">${statusText[status]}</div>
                </div>
                <div class="progress-item-details" style="display: none; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 0.85em; color: #495057; white-space: pre-wrap; word-break: break-word;"></div>
            `;

            // Add click handler to toggle details
            item.addEventListener('click', () => {
                const details = item.querySelector('.progress-item-details');
                if (details && details.textContent) {
                    details.style.display = details.style.display === 'none' ? 'block' : 'none';
                }
            });

            progressList.appendChild(item);
        }

        function updateProgressItem(artistName, status, statusMessage = null, generatedStyle = null) {
            const itemId = `progress-${artistName.replace(/\s+/g, '-')}`;
            const item = document.getElementById(itemId);
            if (!item) return;

            const icons = {
                pending: 'â¸ï¸',
                processing: 'â³',
                success: 'âœ…',
                skipped: 'â­ï¸',
                failed: 'âŒ'
            };

            const statusText = statusMessage || {
                pending: 'Waiting...',
                processing: 'Generating...',
                success: 'Success',
                skipped: 'Skipped',
                failed: 'Failed'
            }[status];

            item.className = `progress-item ${status}`;

            // Get existing details if any
            const existingDetails = item.querySelector('.progress-item-details');
            const existingDetailsContent = existingDetails ? existingDetails.textContent : '';
            const existingDetailsDisplay = existingDetails ? existingDetails.style.display : 'none';

            item.innerHTML = `
                <div class="progress-item-row">
                    <div class="progress-item-icon">${icons[status]}</div>
                    <div class="progress-item-name">${artistName}</div>
                    <div class="progress-item-status">${statusText}</div>
                </div>
                <div class="progress-item-details" style="display: ${existingDetailsDisplay}; padding: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; font-size: 0.85em; color: #495057; white-space: pre-wrap; word-break: break-word;">${generatedStyle || existingDetailsContent}</div>
            `;

            // Re-add click handler
            item.addEventListener('click', () => {
                const details = item.querySelector('.progress-item-details');
                if (details && details.textContent) {
                    details.style.display = details.style.display === 'none' ? 'block' : 'none';
                }
            });

            // Scroll to current item
            item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        async function downloadJSON() {
            try {
                const response = await fetch(`${API_URL}/api/artists`);
                const data = await response.json();

                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'artist_styles.json';
                link.click();
                URL.revokeObjectURL(url);

                showAlert('âœ… JSON ×”×•×¨×“ ×‘×”×¦×œ×—×”!', 'success');
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            }
        }

        async function openJsonEditor() {
            try {
                const response = await fetch(`${API_URL}/api/artists`);
                const data = await response.json();

                const textarea = document.getElementById('jsonEditorTextarea');
                textarea.value = JSON.stringify(data, null, 2);

                document.getElementById('jsonEditorModal').classList.add('active');
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            }
        }

        function closeJsonEditor() {
            document.getElementById('jsonEditorModal').classList.remove('active');
        }

        async function saveEditedJson() {
            const textarea = document.getElementById('jsonEditorTextarea');
            const saveBtn = document.getElementById('saveJsonBtn');
            const originalText = saveBtn.textContent;

            try {
                // Validate JSON
                const data = JSON.parse(textarea.value);

                saveBtn.disabled = true;
                saveBtn.textContent = 'â³ ×©×•××¨...';

                const response = await fetch(`${API_URL}/api/upload-json`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data,
                        password: sessionPassword
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert('âœ… JSON × ×©××¨ ×‘×”×¦×œ×—×”!', 'success');
                    closeJsonEditor();
                    loadArtists();
                } else {
                    throw new Error(result.error || 'Failed to save');
                }
            } catch (error) {
                if (error instanceof SyntaxError) {
                    showAlert('×©×’×™××”: JSON ×œ× ×ª×§×™×Ÿ!', 'error');
                } else {
                    showAlert('×©×’×™××”: ' + error.message, 'error');
                }
            } finally {
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }

        async function handleJsonUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                const response = await fetch(`${API_URL}/api/upload-json`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data,
                        password: sessionPassword
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert('âœ… JSON ×”×•×¢×œ×” ×‘×”×¦×œ×—×”!', 'success');
                    loadArtists();
                } else {
                    throw new Error(result.error || 'Failed to upload');
                }
            } catch (error) {
                if (error instanceof SyntaxError) {
                    showAlert('×©×’×™××”: JSON ×œ× ×ª×§×™×Ÿ!', 'error');
                } else {
                    showAlert('×©×’×™××”: ' + error.message, 'error');
                }
            }

            // Reset file input
            event.target.value = '';
        }

        async function clearAllArtists() {
            if (!confirm('×”×× ××ª×” ×‘×˜×•×—? ×–×” ×™××—×§ ××ª ×›×œ ×”× ×ª×•× ×™×! (×™×•×•×¦×¨ backup ××•×˜×•××˜×™)')) {
                return;
            }

            if (!confirm('××–×”×¨×” ××—×¨×•× ×”! ×›×œ ×”× ×ª×•× ×™× ×™×™××—×§×•. ×”×× ×œ×”××©×™×š?')) {
                return;
            }

            try {
                const response = await fetch(`${API_URL}/api/clear-all`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: sessionPassword })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert('âœ… ×›×œ ×”× ×ª×•× ×™× × ××—×§×•! (backup × ×©××¨)', 'success');
                    selectedArtists.clear();
                    loadArtists();
                } else {
                    throw new Error(result.error || 'Failed to clear');
                }
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            }
        }

        let currentPromptType = '';

        async function openPromptEditor(type) {
            currentPromptType = type;

            const title = document.getElementById('promptEditorTitle');
            const desc = document.getElementById('promptEditorDesc');
            const textarea = document.getElementById('promptEditorTextarea');

            if (type === 'artist') {
                title.textContent = 'ğŸ¤ Edit Artist Prompt';
                desc.textContent = 'Edit the AI prompt for generating artist styles. Use {ARTIST_NAME} as placeholder.';
            } else {
                title.textContent = 'ğŸµ Edit Song Prompt';
                desc.textContent = 'Edit the AI prompt for generating song styles. Use {SONG_NAME} as placeholder.';
            }

            try {
                const response = await fetch(`${API_URL}/api/prompts`);
                const prompts = await response.json();

                if (response.ok) {
                    textarea.value = prompts[type] || '';
                } else {
                    throw new Error(prompts.error || 'Failed to load prompt');
                }

                document.getElementById('promptEditorModal').classList.add('active');
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            }
        }

        function closePromptEditor() {
            document.getElementById('promptEditorModal').classList.remove('active');
        }

        async function savePrompt() {
            const textarea = document.getElementById('promptEditorTextarea');
            const content = textarea.value.trim();
            const saveBtn = document.getElementById('savePromptBtn');
            const originalText = saveBtn.textContent;

            if (!content) {
                showAlert('Prompt cannot be empty!', 'error');
                return;
            }

            saveBtn.disabled = true;
            saveBtn.textContent = 'â³ ×©×•××¨...';

            try {
                const response = await fetch(`${API_URL}/api/prompts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: currentPromptType,
                        content: content,
                        password: sessionPassword
                    })
                });

                const result = await response.json();

                if (response.ok) {
                    showAlert(`âœ… ${currentPromptType} prompt saved!`, 'success');
                    closePromptEditor();
                } else {
                    throw new Error(result.error || 'Failed to save');
                }
            } catch (error) {
                showAlert('×©×’×™××”: ' + error.message, 'error');
            } finally {
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/'/g, "\\'");
        }

        function normalizeArtistName(name) {
            return name
                .normalize('NFD') // Decompose combined characters
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .toLowerCase()
                .trim();
        }

        function showAlert(message, type) {
            const alertContainer = document.getElementById('alertContainer');
            const alertClass = type === 'error' ? 'alert-error' : 'alert-success';

            alertContainer.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;

            setTimeout(() => {
                alertContainer.innerHTML = '';
            }, 5000);
        }
    </script>
</body>
</html>
